{
  "version": 3,
  "sources": ["../../../../node_modules/resilient-fetcher/src/index.ts", "../../../../node_modules/nano-safe-storage/src/index.ts", "../../../../node_modules/feed-slurp/dist/index.mjs"],
  "sourcesContent": ["export interface ResilientOptions {\n    /** Number of retry attempts (default: 3) */\n    retries?: number;\n    /** Delay between retries in ms (default: 1000) */\n    retryDelay?: number;\n    /** Request timeout in ms (default: 5000) */\n    timeout?: number;\n    /** Backoff strategy: 'fixed' | 'exponential' (default: 'fixed') */\n    backoff?: 'fixed' | 'exponential';\n    /** Custom condition to determine if request should be retried */\n    retryOn?: (error: Error | null, response: Response | null) => boolean;\n    /** Request interceptor */\n    onRequest?: (url: string, options: RequestInit) => RequestInit | Promise<RequestInit>;\n    /** Response interceptor */\n    onResponse?: (response: Response) => Response | Promise<Response>;\n    /** Error handler */\n    onError?: (error: Error) => void;\n}\n\n/**\n * Calculates delay with optional exponential backoff and jitter.\n */\nfunction calculateDelay(attempt: number, baseDelay: number, backoff: 'fixed' | 'exponential'): number {\n    if (backoff === 'exponential') {\n        const exponentialDelay = baseDelay * Math.pow(2, attempt - 1);\n        const jitter = Math.random() * 0.3 * exponentialDelay; // 0-30% jitter\n        return exponentialDelay + jitter;\n    }\n    return baseDelay;\n}\n\n/**\n * Default retry condition: retry on network errors and 5xx responses.\n */\nconst defaultRetryOn = (_error: Error | null, response: Response | null): boolean => {\n    if (!response) return true; // Network error\n    return response.status >= 500;\n};\n\n/**\n * A resilient wrapper around the native fetch API with retry and timeout capabilities.\n *\n * @example\n * const response = await resilientFetch('https://api.example.com/data');\n * \n * const response = await resilientFetch('https://api.example.com/data', {\n *   retries: 3,\n *   timeout: 10000,\n *   backoff: 'exponential'\n * });\n */\nexport async function resilientFetch(\n    url: string | URL | Request,\n    options: RequestInit & ResilientOptions = {}\n): Promise<Response> {\n    const {\n        retries = 3,\n        retryDelay = 1000,\n        timeout = 5000,\n        backoff = 'fixed',\n        retryOn = defaultRetryOn,\n        onRequest,\n        onResponse,\n        onError,\n        ...fetchOptions\n    } = options;\n\n    let attempt = 0;\n    let finalUrl = url.toString();\n    let finalOptions: RequestInit = fetchOptions;\n\n    // Apply request interceptor\n    if (onRequest) {\n        finalOptions = await onRequest(finalUrl, fetchOptions);\n    }\n\n    while (true) {\n        const controller = new AbortController();\n        const timeoutId = setTimeout(() => controller.abort(), timeout);\n\n        try {\n            const response = await fetch(finalUrl, {\n                ...finalOptions,\n                signal: controller.signal\n            });\n\n            clearTimeout(timeoutId);\n\n            if (!response.ok) {\n                // Check if we should retry\n                if (attempt < retries && retryOn(null, response)) {\n                    attempt++;\n                    const delay = calculateDelay(attempt, retryDelay, backoff);\n                    await new Promise(resolve => setTimeout(resolve, delay));\n                    continue;\n                }\n                throw new Error(`Request failed with status ${response.status}`);\n            }\n\n            // Apply response interceptor\n            if (onResponse) {\n                return await onResponse(response);\n            }\n\n            return response;\n        } catch (error) {\n            clearTimeout(timeoutId);\n            attempt++;\n\n            const isAbort = (error as Error).name === 'AbortError';\n            const err = isAbort ? new Error('Request timed out') : error as Error;\n\n            // Call error handler\n            if (onError) {\n                onError(err);\n            }\n\n            // Check if we should retry\n            if (attempt <= retries && retryOn(err, null)) {\n                const delay = calculateDelay(attempt, retryDelay, backoff);\n                await new Promise(resolve => setTimeout(resolve, delay));\n                continue;\n            }\n\n            throw err;\n        }\n    }\n}\n\nexport default resilientFetch;\n", "export interface StorageOptions {\n    /** Key prefix for namespacing (default: '') */\n    prefix?: string;\n    /** Default TTL in seconds (optional) */\n    ttl?: number;\n}\n\nexport interface SetOptions {\n    /** TTL for this specific item in seconds */\n    ttl?: number;\n}\n\ninterface StoredValue<T> {\n    value: T;\n    expiry?: number;\n}\n\n// In-memory fallback store\nconst memoryStore: Record<string, string> = {};\n\nconst memoryFallback = {\n    getItem: (key: string): string | null => memoryStore[key] ?? null,\n    setItem: (key: string, value: string): void => {\n        memoryStore[key] = value;\n    },\n    removeItem: (key: string): void => {\n        delete memoryStore[key];\n    },\n    clear: (): void => {\n        for (const key in memoryStore) delete memoryStore[key];\n    }\n};\n\n// Detect available storage\nfunction getStorage(): Storage | typeof memoryFallback {\n    try {\n        if (typeof window !== 'undefined' && window.localStorage) {\n            const testKey = '__nano_safe_test__';\n            window.localStorage.setItem(testKey, testKey);\n            window.localStorage.removeItem(testKey);\n            return window.localStorage;\n        }\n    } catch {\n        // localStorage unavailable (Safari Private Mode, etc.)\n    }\n    return memoryFallback;\n}\n\nconst storage = getStorage();\n\n/**\n * Creates a namespaced storage instance with optional TTL support.\n */\nexport function createStorage(options: StorageOptions = {}) {\n    const { prefix = '', ttl: defaultTtl } = options;\n\n    const prefixKey = (key: string) => `${prefix}${key}`;\n\n    return {\n        /**\n         * Sets a value in storage with optional TTL.\n         */\n        set<T>(key: string, value: T, setOptions?: SetOptions): void {\n            try {\n                const ttl = setOptions?.ttl ?? defaultTtl;\n                const stored: StoredValue<T> = {\n                    value,\n                    expiry: ttl ? Date.now() + ttl * 1000 : undefined\n                };\n                storage.setItem(prefixKey(key), JSON.stringify(stored));\n            } catch (err) {\n                console.warn(`nano-safe-storage: set failed for key \"${key}\"`, err);\n            }\n        },\n\n        /**\n         * Gets a value from storage. Returns null if expired or not found.\n         */\n        get<T>(key: string): T | null {\n            try {\n                const raw = storage.getItem(prefixKey(key));\n                if (raw === null) return null;\n\n                const stored: StoredValue<T> = JSON.parse(raw);\n\n                // Check expiry\n                if (stored.expiry && Date.now() > stored.expiry) {\n                    this.remove(key);\n                    return null;\n                }\n\n                return stored.value;\n            } catch {\n                return null;\n            }\n        },\n\n        /**\n         * Removes an item from storage.\n         */\n        remove(key: string): void {\n            try {\n                storage.removeItem(prefixKey(key));\n            } catch (err) {\n                console.warn(`nano-safe-storage: remove failed for key \"${key}\"`, err);\n            }\n        },\n\n        /**\n         * Checks if a key exists and is not expired.\n         */\n        has(key: string): boolean {\n            return this.get(key) !== null;\n        },\n\n        /**\n         * Clears all items with the current prefix.\n         */\n        clear(): void {\n            try {\n                if (prefix && typeof window !== 'undefined' && window.localStorage) {\n                    const keys = Object.keys(localStorage).filter(k => k.startsWith(prefix));\n                    keys.forEach(k => localStorage.removeItem(k));\n                } else {\n                    storage.clear();\n                }\n            } catch (err) {\n                console.warn('nano-safe-storage: clear failed', err);\n            }\n        },\n\n        /**\n         * Checks if storage is available (not using memory fallback).\n         */\n        isAvailable(): boolean {\n            return storage !== memoryFallback;\n        }\n    };\n}\n\n// Default instance without prefix\nconst defaultStorage = createStorage();\n\nexport const { set: setItem, get: getItem, remove: removeItem, has, clear } = {\n    set: defaultStorage.set.bind(defaultStorage),\n    get: defaultStorage.get.bind(defaultStorage),\n    remove: defaultStorage.remove.bind(defaultStorage),\n    has: defaultStorage.has.bind(defaultStorage),\n    clear: defaultStorage.clear.bind(defaultStorage)\n};\n\nexport default createStorage;\n", "// src/fetcher.ts\nimport { resilientFetch } from \"resilient-fetcher\";\nasync function fetchFeedXml(url, options = {}) {\n  const { proxy, timeout = 1e4, retries = 3 } = options;\n  let requestUrl = url;\n  if (proxy) {\n    if (typeof proxy === \"function\") {\n      requestUrl = proxy(url);\n    } else {\n      switch (proxy) {\n        case \"allorigins\":\n          requestUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;\n          break;\n        case \"corsproxy\":\n          requestUrl = `https://corsproxy.io/?${encodeURIComponent(url)}`;\n          break;\n        default:\n          requestUrl = `${proxy}${encodeURIComponent(url)}`;\n      }\n    }\n  }\n  const response = await resilientFetch(requestUrl, {\n    retries,\n    timeout\n  });\n  if (!response.ok) {\n    throw new Error(`Failed to fetch feed: ${response.status} ${response.statusText}`);\n  }\n  return response.text();\n}\n\n// src/parser/xml.ts\nfunction parseXml(xmlString) {\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(xmlString, \"text/xml\");\n  const parseError = doc.getElementsByTagName(\"parsererror\");\n  if (parseError.length > 0) {\n    throw new Error(`XML parsing failed: ${parseError[0].textContent}`);\n  }\n  return doc;\n}\nfunction getText(node, selector) {\n  if (!node) return \"\";\n  const el = node.querySelector(selector);\n  return el?.textContent?.trim() || \"\";\n}\nfunction getCDataOrText(node, selectors) {\n  if (!node) return \"\";\n  for (const selector of selectors) {\n    const el = node.querySelector(selector.replace(\":\", \"\\\\:\"));\n    if (el) return el.textContent?.trim() || \"\";\n  }\n  return \"\";\n}\n\n// src/parser/rss.ts\nfunction parseRss(doc) {\n  const channel = doc.querySelector(\"channel\");\n  if (!channel) throw new Error(\"Invalid RSS feed: Missing <channel>\");\n  const items = Array.from(doc.querySelectorAll(\"item\")).map((item) => {\n    const description = getText(item, \"description\");\n    const content = getCDataOrText(item, [\"content:encoded\", \"description\"]);\n    return {\n      title: getText(item, \"title\"),\n      link: getText(item, \"link\"),\n      pubDate: new Date(getText(item, \"pubDate\")).toISOString(),\n      description,\n      content,\n      author: getText(item, \"dc\\\\:creator\") || \"Unknown\",\n      categories: Array.from(item.querySelectorAll(\"category\")).map((c) => c.textContent || \"\"),\n      guid: getText(item, \"guid\") || getText(item, \"link\"),\n      thumbnail: extractThumbnail(item, content)\n    };\n  });\n  return {\n    title: getText(channel, \"title\"),\n    description: getText(channel, \"description\"),\n    link: getText(channel, \"link\"),\n    lastBuildDate: getText(channel, \"lastBuildDate\") || (/* @__PURE__ */ new Date()).toISOString(),\n    items\n  };\n}\nfunction extractThumbnail(item, content) {\n  const mediaTags = [\"media\\\\:content\", \"media\\\\:thumbnail\", \"content\", \"thumbnail\"];\n  for (const tag of mediaTags) {\n    const el = item.querySelector(tag);\n    if (el) {\n      const url = el.getAttribute(\"url\") || el.getAttribute(\"src\");\n      if (url) return url;\n    }\n  }\n  const enclosure = item.querySelector(\"enclosure[type^='image']\");\n  if (enclosure) {\n    const url = enclosure.getAttribute(\"url\");\n    if (url) return url;\n  }\n  const imgRegex = /<img[^>]+src=[\"']([^\"']+)[\"']/i;\n  const match = content.match(imgRegex);\n  if (match && match[1]) return match[1];\n  return null;\n}\n\n// src/parser/atom.ts\nfunction parseAtom(doc) {\n  const feed = doc.querySelector(\"feed\");\n  if (!feed) throw new Error(\"Invalid Atom feed: Missing <feed>\");\n  const items = Array.from(doc.querySelectorAll(\"entry\")).map((entry) => {\n    const content = getText(entry, \"content\") || getText(entry, \"summary\");\n    return {\n      title: getText(entry, \"title\"),\n      link: entry.querySelector(\"link[rel='alternate']\")?.getAttribute(\"href\") || entry.querySelector(\"link\")?.getAttribute(\"href\") || \"\",\n      pubDate: new Date(getText(entry, \"updated\") || getText(entry, \"published\")).toISOString(),\n      description: getText(entry, \"summary\"),\n      content,\n      author: getText(entry, \"author name\") || \"Unknown\",\n      categories: Array.from(entry.querySelectorAll(\"category\")).map((c) => c.getAttribute(\"term\") || \"\"),\n      guid: getText(entry, \"id\"),\n      thumbnail: extractThumbnail2(entry, content)\n    };\n  });\n  return {\n    title: getText(feed, \"title\"),\n    description: getText(feed, \"subtitle\") || \"\",\n    link: feed.querySelector(\"link[rel='alternate']\")?.getAttribute(\"href\") || feed.querySelector(\"link\")?.getAttribute(\"href\") || \"\",\n    lastBuildDate: getText(feed, \"updated\"),\n    items\n  };\n}\nfunction extractThumbnail2(entry, content) {\n  const enclosure = entry.querySelector(\"link[rel='enclosure'][type^='image']\");\n  if (enclosure) return enclosure.getAttribute(\"href\");\n  const match = content.match(/<img[^>]+src=\"([^\">]+)\"/);\n  return match ? match[1] : null;\n}\n\n// src/cache.ts\nimport { createStorage } from \"nano-safe-storage\";\nvar storage = createStorage({\n  prefix: \"slurp_\",\n  ttl: 3600\n  // Default 1 hour\n});\nfunction getCachedFeed(key) {\n  return storage.get(key);\n}\nfunction setCachedFeed(key, feed, ttl) {\n  storage.set(key, feed, ttl ? { ttl } : void 0);\n}\nfunction clearSlurpCache(key) {\n  if (key) {\n    storage.remove(key);\n  } else {\n    storage.clear();\n  }\n}\n\n// src/index.ts\nasync function slurp(url, options = {}) {\n  const { cache = true, cacheTTL, cacheKey = url } = options;\n  if (cache) {\n    const cached = getCachedFeed(cacheKey);\n    if (cached) return cached;\n  }\n  const xml = await fetchFeedXml(url, options);\n  const doc = parseXml(xml);\n  const isAtom = doc.querySelector(\"feed\") !== null;\n  const feed = isAtom ? parseAtom(doc) : parseRss(doc);\n  if (cache) {\n    setCachedFeed(cacheKey, feed, cacheTTL);\n  }\n  return feed;\n}\nfunction createSlurper(defaultOptions = {}) {\n  return {\n    slurp: (url, options = {}) => slurp(url, { ...defaultOptions, ...options }),\n    clearCache: (key) => clearSlurpCache(key)\n  };\n}\nexport {\n  clearSlurpCache,\n  createSlurper,\n  slurp\n};\n"],
  "mappings": "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",
  "names": ["calculateDelay", "attempt", "baseDelay", "backoff", "exponentialDelay", "jitter", "defaultRetryOn", "_error", "response", "resilientFetch", "url", "options", "retries", "retryDelay", "timeout", "retryOn", "onRequest", "onResponse", "onError", "fetchOptions", "finalUrl", "finalOptions", "controller", "timeoutId", "delay", "resolve", "error", "err", "memoryStore", "memoryFallback", "key", "value", "getStorage", "testKey", "storage", "createStorage", "options", "prefix", "defaultTtl", "prefixKey", "setOptions", "ttl", "stored", "err", "raw", "k", "defaultStorage", "setItem", "getItem", "removeItem", "has", "clear", "_a", "_b"]
}
